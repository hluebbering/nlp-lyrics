[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "https://www.tensorflow.org/install https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment?text=I+like+you.+I+love+you https://aeturrell.github.io/coding-for-economists/vis-common-plots.html"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NLP Song Lyrics",
    "section": "",
    "text": "Spotify API\nGoal. Using machine learning to predict the mood of music from song lyrics and audio features.\nThe following project uses Python implementation that extracts and analyzes information about songs in a Spotify playlist using the Spotify Web API. We then use the lyricsgenius package to search for and save the lyrics of specific songs from the Genius lyrics website. We then implement a Python script that contains several functions for cleaning song lyrics and determining the sentiment of the lyrics.\nIn summary, the code retrieves and cleans song lyrics, removes stopwords and performs lemmatization, and finally determines the sentiment of the lyrics using pre-trained models for sentiment analysis.\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nimport pandas as pd\nfrom IPython.core.display import HTML\n\nclient_id = \"3899576b5fcb4c458beba2cce99aa1b6\"\nclient_secret = \"092a0b9b1e074abba82ce61ba6137aea\"\nsp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(client_id, client_secret))\nThe given code is a Python script that contains several functions for cleaning song lyrics and determining the sentiment of the lyrics.\nimport lyricsgenius\nimport requests\nfrom bs4 import BeautifulSoup\n\ngenius = lyricsgenius.Genius(\"epFCxujgBe-Y6WrkZedI8kerKxiCpR6Rh0DAHYNlKDf9B4H1nXTdZIkj7krNUHVV\")\n\n# song = genius.search_song(\"Too Many Nights\", \"Metro Boomin\")\nsong = genius.search_song(\"No Good\", \"Juice WRLD\")\n# song.save_lyrics()\n\nSearching for \"No Good\" by Juice WRLD...\n\n\nDone.\nlyrics_dict = {}\ndict_ls = []\n\nfor i in range(len(df)):\n    song_name = df['name'][i].partition(' (')[0]\n    artist_name = df['artist'][i]\n    track_lyrics = clean_song_lyrics(song_name, artist_name)\n    track_lyrics = remove_stopwords_lyrics(track_lyrics)\n    \n    for k in (track_lyrics):\n        if k in lyrics_dict:\n            lyrics_dict[k] += 1\n        else:\n            lyrics_dict[k] = 1\n            \n    sent_score = get_lyric_sentiment(track_lyrics)\n    sent_score['track_name'] = song_name\n    sent_score['artist_name'] = artist_name\n    sent_score['release_date'] = df['release_date'][i]\n    sent_score['length'] = df['length'][i]\n    sent_score['popularity'] = df['popularity'][i]\n    sent_score['artist_pop'] = df['artist_pop'][i]\n    sent_score['artist_genres'] = df['artist_genres'][i]\n    sent_score['acousticness'] = df['acousticness'][i]\n    sent_score['danceability'] = df['danceability'][i]\n    sent_score['energy'] = df['energy'][i]\n    sent_score['instrumentalness'] = df['instrumentalness'][i]\n    sent_score['liveness'] = df['liveness'][i]\n    sent_score['loudness'] = df['loudness'][i]\n    sent_score['speechiness'] = df['speechiness'][i]\n    sent_score['tempo'] = df['tempo'][i]\n    sent_score['valence'] = df['valence'][i]\n    \n    dict_ls.append(sent_score)\n\nSearching for \"What Was I Made For? [From The Motion Picture \"Barbie\"]\" by Billie Eilish...\nDone.\nSearching for \"vampire\" by Olivia Rodrigo...\nDone.\nSearching for \"Cruel Summer\" by Taylor Swift...\nDone.\nSearching for \"Popular\" by The Weeknd...\nDone.\nSearching for \"Dance The Night\" by Dua Lipa...\nDone.\nSearching for \"WHERE SHE GOES\" by Bad Bunny...\nDone.\nSearching for \"Barbie World\" by Nicki Minaj...\nDone.\nSearching for \"Kill Bill\" by SZA...\nDone.\nSearching for \"As It Was\" by Harry Styles...\nDone.\nSearching for \"Super Shy\" by NewJeans...\nDone.\nSearching for \"Flowers\" by Miley Cyrus...\nDone.\nSearching for \"Calm Down\" by Rema...\nDone.\nSearching for \"Calling\" by Metro Boomin...\nDone.\nSearching for \"fukumean\" by Gunna...\nDone.\nSearching for \"Attention\" by Doja Cat...\nDone.\nSearching for \"Seven\" by Jung Kook...\nDone.\nSearching for \"Cupid - Twin Ver.\" by FIFTY FIFTY...\nDone.\nSearching for \"Chemical\" by Post Malone...\nDone.\nSearching for \"People\" by Libianca...\nDone.\nSearching for \"LALA\" by Myke Towers...\nDone.\nSearching for \"Die For You - Remix\" by The Weeknd...\nDone.\nSearching for \"Baby Don't Hurt Me\" by David Guetta...\nDone.\nSearching for \"Boy's a Liar Pt. 2\" by PinkPantheress...\nDone.\nSearching for \"Columbia\" by Quevedo...\nDone.\nSearching for \"All My Life\" by Lil Durk...\nDone.\nSearching for \"Daylight\" by David Kushner...\nDone.\nSearching for \"Creepin'\" by Metro Boomin...\nDone.\nSearching for \"MOJABI GHOST\" by Tainy...\nDone.\nSearching for \"Moonlight\" by Kali Uchis...\nDone.\nSearching for \"Snooze\" by SZA...\nDone.\nSearching for \"Fast Car\" by Luke Combs...\nDone.\nSearching for \"Karma\" by Taylor Swift...\nDone.\nSearching for \"I Ain't Worried\" by OneRepublic...\nDone.\nSearching for \"Rush\" by Troye Sivan...\nDone.\nSearching for \"What It Is\" by Doechii...\nDone.\nSearching for \"I'm Good\" by David Guetta...\nDone.\nSearching for \"Until I Found You\" by Stephen Sanchez...\nDone.\nSearching for \"Eyes Closed\" by Ed Sheeran...\nDone.\nSearching for \"golden hour\" by JVKE...\nDone.\nSearching for \"Ella Baila Sola\" by Eslabon Armado...\nDone.\nSearching for \"Say Yes To Heaven\" by Lana Del Rey...\nDone.\nSearching for \"CUFF IT\" by Beyoncé...\nDone.\nSearching for \"Here With Me\" by d4vd...\nDone.\nSearching for \"Mona Lisa\" by Dominic Fike...\nDone.\nSearching for \"Nonsense\" by Sabrina Carpenter...\nDone.\nSearching for \"Miracle\" by Calvin Harris...\nDone.\nSearching for \"(It Goes Like) Nanana - Edit\" by Peggy Gou...\nDone.\nSearching for \"Sprinter\" by Dave...\nDone.\nSearching for \"Last Night\" by Morgan Wallen...\nDone.\nSearching for \"Unholy\" by Sam Smith...\nDone.\ndf_final = pd.DataFrame(dict_ls)\ndf_final = df_final[['track_name', 'artist_name', 'release_date', 'length', 'popularity', \n         'artist_pop', 'artist_genres', 'acousticness', 'danceability', 'energy',\n         'instrumentalness', 'liveness', 'loudness', 'speechiness', 'tempo', 'valence',\n         'sadness', 'joy', 'love', 'anger', 'fear', 'surprise', 'LABEL_0',\n         'LABEL_1', 'LABEL_2', 'NEGATIVE', 'POSITIVE']]\n\n# df_final.to_csv('top_songs_us.csv', index=False)\ntrack_name\nartist_name\nrelease_date\nlength\npopularity\nartist_pop\nartist_genres\nacousticness\ndanceability\nenergy\n...\njoy\nlove\nanger\nfear\nsurprise\nLABEL_0\nLABEL_1\nLABEL_2\nNEGATIVE\nPOSITIVE\n\n\n\n\n0\nWhat Was I Made For? [From The Motion Picture \"Barbie\"]\nBillie Eilish\n2023-07-13\n222369\n84\n86\n[art pop, electropop, pop]\n0.959\n0.444\n0.0911\n...\n0.197081\n0.009966\n0.345436\n0.179204\n0.008392\n0.095024\n0.854509\n0.050466\n0.971982\n0.028018\n\n\n1\nvampire\nOlivia Rodrigo\n2023-06-30\n219724\n98\n84\n[pop]\n0.169\n0.511\n0.5320\n...\n0.993057\n0.000612\n0.001648\n0.001187\n0.000837\n0.727187\n0.240037\n0.032776\n0.998202\n0.001798\n\n\n2\nCruel Summer\nTaylor Swift\n2019-08-23\n178426\n99\n100\n[pop]\n0.117\n0.552\n0.7020\n...\n0.241193\n0.017412\n0.405512\n0.024407\n0.003616\n0.287019\n0.607944\n0.105037\n0.994126\n0.005874\n\n\n\n\n3 rows × 27 columns\nIn summary, the code retrieves and cleans song lyrics, removes stopwords and performs lemmatization, and finally determines the sentiment of the lyrics using pre-trained models for sentiment analysis."
  },
  {
    "objectID": "index.html#display-spotify-playlists",
    "href": "index.html#display-spotify-playlists",
    "title": "NLP Song Lyrics",
    "section": "Display Spotify Playlists",
    "text": "Display Spotify Playlists\n\n\n\n\n\n\nthumbnail\nplaylist_name\nplaylist_id\ndescription\ntotal\n\n\n\n\n0\n\nToday's Top Hits\n37i9dQZF1DXcBWIGoYBM5M\nBillie Eilish is on top of the Hottest 50!\n50\n\n\n1\n\nRapCaviar\n37i9dQZF1DX0XUsuxWHRQd\nNew music from Lil Tjay, Quavo and JT of City Girls.\n50\n\n\n2\n\nHot Country\n37i9dQZF1DX1lVhptIYRda\nToday's top country hits. Cover: Dan + Shay\n50\n\n\n3\n\nViva Latino\n37i9dQZF1DX10zKzsJ2jva\nToday's top Latin hits, elevando nuestra música. Cover: KAROL G\n50\n\n\n4\n\nNew Music Friday\n37i9dQZF1DX4JAvHpjipBk\nNew music from Billie Eilish, KAROL G, Post Malone, Troye Sivan, Lil Tjay & Summer Walker, Dan + Shay and more!\n100"
  },
  {
    "objectID": "index.html#get-tracks-from-playlist",
    "href": "index.html#get-tracks-from-playlist",
    "title": "NLP Song Lyrics",
    "section": "Get Tracks from Playlist",
    "text": "Get Tracks from Playlist\nThe following code allows you to extract various details about songs in a Spotify playlist, such as their names, track IDs, album names, artist names, audio features, and playlist information. The extracted information is then organized and displayed in a pandas DataFrame.\n\n# Get playlist song features and artist info\ndef playlist_features(id, artist_id, playlist_id):\n    \n    # Create Spotify API client variables\n    meta = sp.track(id)\n    audio_features = sp.audio_features(id)\n    artist_info = sp.artist(artist_id)\n    playlist_info = sp.playlist(playlist_id)\n\n    # Metadata\n    name = meta['name']\n    track_id = meta['id']\n    album = meta['album']['name']\n    artist = meta['album']['artists'][0]['name']\n    artist_id = meta['album']['artists'][0]['id']\n    release_date = meta['album']['release_date']\n    length = meta['duration_ms']\n    popularity = meta['popularity']\n\n    # Main artist name, popularity, genre\n    artist_pop = artist_info[\"popularity\"]\n    artist_genres = artist_info[\"genres\"]\n\n    # Track features\n    acousticness = audio_features[0]['acousticness']\n    danceability = audio_features[0]['danceability']\n    energy = audio_features[0]['energy']\n    instrumentalness = audio_features[0]['instrumentalness']\n    liveness = audio_features[0]['liveness']\n    loudness = audio_features[0]['loudness']\n    speechiness = audio_features[0]['speechiness']\n    tempo = audio_features[0]['tempo']\n    valence = audio_features[0]['valence']\n    key = audio_features[0]['key']\n    mode = audio_features[0]['mode']\n    time_signature = audio_features[0]['time_signature']\n    \n    # Basic playlist info\n    playlist_name = playlist_info['name']\n\n    return [name, track_id, album, artist, artist_id, release_date, length, popularity, \n            artist_pop, artist_genres, acousticness, danceability, \n            energy, instrumentalness, liveness, loudness, speechiness, \n            tempo, valence, key, mode, time_signature, playlist_name]\n\n\ndef get_playlist_tracks(playlist_URI):\n    tracks = []\n    results = sp.playlist_tracks(playlist_URI)\n    tracks = results[\"items\"]\n    while results[\"next\"]:\n        results = sp.next(results)\n        tracks.extend(results[\"items\"])\n    return tracks\n\nChoose a specific playlist to analyze by copying the URL from the Spotify Player interface. Using that link, the following code uses the playlist_tracks method to retrieve a list of IDs and corresponding artists for each track from the playlist.\n\n# Spotify playlist url\nplaylist_ids = []\ntrack_ids = []\nartist_uris = []\n\n# Extract song ids and artists from playlist\nplaylist_URI = \"37i9dQZF1DXcBWIGoYBM5M\"\nfor i in get_playlist_tracks(playlist_URI):\n    track_ids.append(i[\"track\"][\"id\"])\n    artist_uris.append(i[\"track\"][\"artists\"][0][\"uri\"])\n    playlist_ids.append(playlist_URI)\n\nThe following code loops through each track ID in the playlist and extracts additional song information by calling the function we created above. From there, we can create a pandas data frame by passing in the extracted information and giving the column header names we want.\n\n# Loop over track ids\nall_tracks = [\n    playlist_features(track_ids[i], artist_uris[i], playlist_ids[i])\n    for i in range(len(track_ids))\n]\n\n\n\n\n\n\n\n\n\n\nname\nartist\nrelease_date\npopularity\nartist_pop\nartist_genres\nacousticness\ndanceability\nenergy\ninstrumentalness\nliveness\nloudness\nspeechiness\ntempo\nvalence\nplaylist\n\n\n\n\n0\nWhat Was I Made For? [From The Motion Picture \"Barbie\"]\nBillie Eilish\n2023-07-13\n84\n86\n[art pop, electropop, pop]\n0.9590\n0.444\n0.0911\n0.000001\n0.098\n-17.665\n0.0307\n78.403\n0.142\nToday's Top Hits\n\n\n1\nvampire\nOlivia Rodrigo\n2023-06-30\n98\n84\n[pop]\n0.1690\n0.511\n0.5320\n0.000000\n0.311\n-5.745\n0.0560\n137.827\n0.322\nToday's Top Hits\n\n\n2\nCruel Summer\nTaylor Swift\n2019-08-23\n99\n100\n[pop]\n0.1170\n0.552\n0.7020\n0.000021\n0.105\n-5.707\n0.1570\n169.994\n0.564\nToday's Top Hits\n\n\n3\nPopular (with Playboi Carti & Madonna) - Music from the HBO Original Series\nThe Weeknd\n2023-06-02\n91\n93\n[canadian contemporary r&b, canadian pop, pop]\n0.0569\n0.855\n0.6780\n0.000037\n0.412\n-6.276\n0.1890\n99.029\n0.852\nToday's Top Hits\n\n\n4\nDance The Night (From Barbie The Album)\nDua Lipa\n2023-05-25\n94\n85\n[dance pop, pop, uk pop]\n0.0207\n0.671\n0.8450\n0.000000\n0.329\n-4.930\n0.0480\n110.056\n0.775\nToday's Top Hits\n\n\n5\nWHERE SHE GOES\nBad Bunny\n2023-05-18\n100\n94\n[reggaeton, trap latino, urbano latino]\n0.1430\n0.652\n0.8000\n0.629000\n0.112\n-4.019\n0.0614\n143.978\n0.234\nToday's Top Hits\n\n\n6\nBarbie World (with Aqua) [From Barbie The Album]\nNicki Minaj\n2023-06-23\n91\n85\n[hip pop, pop, queens hip hop, rap]\n0.5190\n0.770\n0.5800\n0.000127\n0.233\n-8.393\n0.2470\n144.072\n0.753\nToday's Top Hits\n\n\n7\nKill Bill\nSZA\n2022-12-08\n95\n87\n[pop, r&b, rap]\n0.0521\n0.644\n0.7350\n0.144000\n0.161\n-5.747\n0.0391\n88.980\n0.418\nToday's Top Hits\n\n\n8\nAs It Was\nHarry Styles\n2022-03-31\n93\n86\n[pop]\n0.3420\n0.520\n0.7310\n0.001010\n0.311\n-5.338\n0.0557\n173.930\n0.662\nToday's Top Hits\n\n\n9\nSuper Shy\nNewJeans\n2023-07-07\n91\n80\n[k-pop, k-pop girl group]\n0.1800\n0.776\n0.8170\n0.000034\n0.146\n-6.018\n0.0748\n149.921\n0.515\nToday's Top Hits\n\n\n\n\n\n\n\n\nTop Artist Genres\n\ngenres_dict = {}\nfor x in df.artist_genres:\n    for ii in x:\n        if ii in genres_dict:\n            genres_dict[ii] += 1\n        else:\n            genres_dict[ii] = 1\nprint(genres_dict)\n\n# Convert Dictionary to Dataframe\ndf_genres = pd.DataFrame(genres_dict.items(), columns=['Genre', 'Freq']).sort_values('Freq', ascending=False)\ndf_genres = df_genres.reset_index(drop = True)\n\n{'art pop': 2, 'electropop': 1, 'pop': 24, 'canadian contemporary r&b': 2, 'canadian pop': 2, 'dance pop': 5, 'uk pop': 3, 'reggaeton': 3, 'trap latino': 4, 'urbano latino': 4, 'hip pop': 1, 'queens hip hop': 1, 'rap': 8, 'r&b': 3, 'k-pop': 2, 'k-pop girl group': 2, 'afrobeats': 2, 'nigerian pop': 1, 'hip hop': 3, 'atl hip hop': 1, 'melodic rap': 2, 'trap': 2, 'dfw rap': 1, 'big room': 2, 'edm': 3, 'pop dance': 2, 'bedroom pop': 2, 'rap canario': 1, 'chicago drill': 1, 'chicago rap': 1, 'drill': 1, 'gen z singer-songwriter': 2, 'singer-songwriter pop': 3, 'pop reggaeton': 1, 'colombian pop': 1, 'contemporary country': 2, 'country': 1, 'piano rock': 1, 'australian pop': 1, 'viral pop': 1, 'alternative r&b': 1, 'modern indie pop': 1, 'pov: indie': 2, 'corrido': 1, 'corridos tumbados': 1, 'sad sierreno': 1, 'sierreno': 1, 'bedroom r&b': 1, 'alternative pop rock': 1, 'electro house': 1, 'house': 1, 'progressive house': 1, 'uk dance': 1, 'electra': 1, 'float house': 1, 'uk hip hop': 1}"
  },
  {
    "objectID": "index.html#nlp",
    "href": "index.html#nlp",
    "title": "NLP Song Lyrics",
    "section": "NLP",
    "text": "NLP\nUsing pipeline class to make predictions from models available in the Hub\n\nimport transformers\nfrom transformers import pipeline\n#import tensorflow as tf\n## python -m pip install \"tensorflow&lt;2.11\"\n# python -m pip install \"protobuf&lt;3.2\"\n\nclassifier = pipeline(\"text-classification\",model='bhadresh-savani/distilbert-base-uncased-emotion', return_all_scores=True)\nclassifier2 = pipeline(\"text-classification\",model='cardiffnlp/twitter-roberta-base-sentiment', return_all_scores=True)\nclassifier3 = pipeline(\"sentiment-analysis\", return_all_scores=True)\n\nDistilbert-base-uncased-emotion is a model fine-tuned for detecting emotions in texts, including sadness, joy, love, anger, fear and surprise\n\ndef get_lyric_sentiment(cleaned_lyrics):\n    song_score = {}\n\n    x = ' '.join(cleaned_lyrics)\n    \n    # classifier = pipeline(\"text-classification\",model='bhadresh-savani/distilbert-base-uncased-emotion', return_all_scores=True)\n    prediction = classifier(x, truncation = True)\n    for j in prediction[0]:\n        song_score[j['label']] = j['score']\n    \n    #classifier2 = pipeline(\"text-classification\",model='cardiffnlp/twitter-roberta-base-sentiment', return_all_scores=True)\n    prediction2 = classifier2(x, truncation=True, max_length=512)\n    for k in prediction2[0]:\n        song_score[k['label']] = k['score']\n        \n    #classifier3 = pipeline(\"sentiment-analysis\", return_all_scores=True)\n    prediction3 = classifier3(x, truncation=True)\n    for k3 in prediction3[0]:\n        song_score[k3['label']] = k3['score']\n        \n    return song_score\n\nHow to handle sequences longer than 512 tokens Exception encountered when calling layer ‘embeddings’"
  },
  {
    "objectID": "index.html#spotify-songs---similarity-search",
    "href": "index.html#spotify-songs---similarity-search",
    "title": "NLP Song Lyrics",
    "section": "Spotify Songs - Similarity Search",
    "text": "Spotify Songs - Similarity Search\nBelow, we create a query to retrieve similar elements based on Euclidean distance. In mathematics, the Euclidean distance between two points is the length of the line segment between the two points. In this sense, the closer the distance is to 0, the more similar the songs are.\n\nKNN Algorithm\nThe k-Nearest Neighbors (KNN) algorithm searches for k similar elements based on a query point at the center within a predefined radius.\n\n# Get a song string search\ndef getMusicName(elem):\n    return f\"{elem['artist']} - {elem['name']}\"\n\ndef knnQuery(queryPoint, arrCharactPoints, k):\n    queryVals = queryPoint.tolist()\n    distVals = []\n    \n    # Copy of dataframe indices and data\n    tmp = arrCharactPoints.copy(deep = True)  \n    for index, row in tmp.iterrows():\n        feat = row.values.tolist()\n        \n        # Calculate sum of squared differences\n        ssd = sum(abs(feat[i] - queryVals[i]) ** 2 for i in range(len(queryVals)))\n        \n        # Get euclidean distance\n        distVals.append(ssd ** 0.5)\n        \n    tmp['distance'] = distVals\n    tmp = tmp.sort_values('distance')\n    \n    # K closest and furthest points\n    return tmp.head(k).index, tmp.tail(k).index\n\n\n# Execute KNN removing the query point\ndef querySimilars(df, columns, idx, func, param):\n    arr = df[columns].copy(deep = True)\n    queryPoint = arr.loc[idx]\n    arr = arr.drop([idx])\n    return func(queryPoint, arr, param)\n\nKNN Query Example.\nOur function allows us to create personalized query points and modify the columns to explore other options. For example, the following code selects a specific set of song attributes and then searches for the \\(k\\) highest values of these attributes set equal to one.\nLet’s search for \\(k=3\\) similar songs to a query point \\(\\textrm{songIndex} = 6\\).\n\nfrom sklearn import preprocessing \n\nscaler=preprocessing.MinMaxScaler() #instantiate a scaler\n# all the feature values are in the range [0,1] ,except of loudnes\n# so let's scale it to fit the exact same range\nloudness2 = df[\"loudness\"].values\nloudness_scaled=scaler.fit_transform(loudness2.reshape(-1, 1))\ndf['loudness_scaled'] = loudness_scaled\n\n\n# Select song and column attributes\nsongIndex = 4 # query point\ncolumns = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness', \n           'loudness_scaled', 'tempo', \n           'speechiness', 'valence']\n\n# Set query parameters\nfunc, param = knnQuery,3\n\n# Implement query\nresponse = querySimilars(df, columns, songIndex, func, param)\n\nprint(\"---- Query Point ----\")\nprint(getMusicName(df.loc[songIndex]))\nprint('---- k = 3 similar songs ----')\nfor track_id in response[0]:\n    track_name = getMusicName(df.loc[track_id])\n    print(track_name)\nprint('---- k = 3 nonsimilar songs ----')\nfor track_id in response[1]:\n    track_name = getMusicName(df.loc[track_id])\n    print(track_name)\n\n---- Query Point ----\nDua Lipa - Dance The Night (From Barbie The Album)\n---- k = 3 similar songs ----\nDominic Fike - Mona Lisa (Spider-Man: Across the Spider-Verse)\nEd Sheeran - Eyes Closed\nRema - Calm Down (with Selena Gomez)\n---- k = 3 nonsimilar songs ----\nDoechii - What It Is (Solo Version)\nHarry Styles - As It Was\nMorgan Wallen - Last Night\n\n\nThe code below implements the same idea as above, but queries each track in a given playlist instead of a single defined query point.\n\nsimilar_count = {} # Similar songs count\nnonsimilar_count = {} # Non-similar songs count\n\nfor track_index in df.index:\n    # Implement query\n    response = querySimilars(df, columns, track_index, func, param)\n    \n    # Get similar songs\n    for similar_index in response[0]:\n        track = getMusicName(df.loc[similar_index])\n        if track in similar_count:\n            similar_count[track] += 1\n        else:\n            similar_count[track] = 1\n    \n    # Get non-similar songs\n    for nonsimilar_index in response[1]:\n        track = getMusicName(df.loc[nonsimilar_index])\n        if track in nonsimilar_count:\n            nonsimilar_count[track] += 1\n        else:\n            nonsimilar_count[track] = 1\n\n\nnonsimilar = dict(sorted(nonsimilar_count.items(), key=lambda item: item[1], reverse=True))\nprint('---- NON SIMILAR SONG COUNTS ----')\nfor track_name, track_count in nonsimilar.items():\n    if track_count &gt;= 8:\n        print(track_name, ':', track_count)\n\nsimilar = dict(sorted(similar_count.items(), key=lambda item: item[1], reverse=True))\nprint('\\n---- SIMILAR SONG COUNTS ----')\nfor track_name, track_count in similar.items():\n    if track_count &gt;= 5:\n        print(track_name, ':', track_count)\n\n---- NON SIMILAR SONG COUNTS ----\nMorgan Wallen - Last Night : 43\nThe Weeknd - Die For You - Remix : 31\nBillie Eilish - What Was I Made For? [From The Motion Picture \"Barbie\"] : 26\nHarry Styles - As It Was : 24\nDoechii - What It Is (Solo Version) : 19\n\n---- SIMILAR SONG COUNTS ----\nSZA - Kill Bill : 5\nOneRepublic - I Ain't Worried : 5\nQuevedo - Columbia : 5\nNicki Minaj - Barbie World (with Aqua) [From Barbie The Album] : 5\nSam Smith - Unholy (feat. Kim Petras) : 5\nGunna - fukumean : 5\nThe Weeknd - Popular (with Playboi Carti & Madonna) - Music from the HBO Original Series : 5"
  },
  {
    "objectID": "index.html#organized-songs-in-a-playlist",
    "href": "index.html#organized-songs-in-a-playlist",
    "title": "NLP Song Lyrics",
    "section": "Organized Songs in a Playlist",
    "text": "Organized Songs in a Playlist\n\nimport datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn import cluster, decomposition\n\n\nsongs = df[['name','acousticness', 'danceability', 'energy', 'instrumentalness', \n            'liveness', 'speechiness', 'tempo', 'valence',  'loudness_scaled']]\nsongs.describe()\n\n\n\n\n\n\n\n\n\nacousticness\ndanceability\nenergy\ninstrumentalness\nliveness\nspeechiness\ntempo\nvalence\nloudness_scaled\n\n\n\n\ncount\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n\n\nmean\n0.262214\n0.669240\n0.659022\n0.025725\n0.177190\n0.076142\n125.244800\n0.511538\n0.784102\n\n\nstd\n0.244049\n0.114132\n0.165292\n0.096359\n0.122158\n0.067282\n27.035927\n0.246883\n0.162872\n\n\nmin\n0.001260\n0.444000\n0.091100\n0.000000\n0.032200\n0.025400\n66.900000\n0.096900\n0.000000\n\n\n25%\n0.065750\n0.563500\n0.555000\n0.000000\n0.097025\n0.035225\n102.642250\n0.304500\n0.704982\n\n\n50%\n0.174500\n0.671000\n0.679500\n0.000008\n0.115000\n0.049200\n127.992000\n0.508500\n0.823084\n\n\n75%\n0.430500\n0.759000\n0.787250\n0.000162\n0.244250\n0.081850\n140.853000\n0.730500\n0.872186\n\n\nmax\n0.959000\n0.916000\n0.965000\n0.629000\n0.563000\n0.327000\n203.853000\n0.964000\n1.000000\n\n\n\n\n\n\n\n\nlabels = songs.values[:,0]\nX = songs.values[:,1:10]\nkmeans = cluster.AffinityPropagation(preference=-200)\nkmeans.fit(X)\n\nAffinityPropagation(preference=-200)\n\n\n\npredictions = {}\nfor p,n in zip(kmeans.predict(X),labels):\n    if not predictions.get(p):\n        predictions[p] = []\n        \n    predictions[p] += [n]\n\nfor p in predictions:\n    print(\"Category\",p)\n    print(\"-----\")\n    for n in predictions[p]:\n        print(n)\n    print(\"\")\n\nCategory 0\n-----\nWhat Was I Made For? [From The Motion Picture \"Barbie\"]\nKill Bill\nAttention\nLALA\nKarma\n\nCategory 4\n-----\nvampire\nWHERE SHE GOES\nBarbie World (with Aqua) [From Barbie The Album]\nSuper Shy\nCalling (Spider-Man: Across the Spider-Verse) (Metro Boomin & Swae Lee, NAV, feat. A Boogie Wit da Hoodie)\nAll My Life (feat. J. Cole)\nMoonlight\nSnooze\nI Ain't Worried\nElla Baila Sola\nNonsense\nMiracle (with Ellie Goulding)\nSprinter\n\nCategory 5\n-----\nCruel Summer\nAs It Was\nChemical\nWhat It Is (Solo Version)\n\nCategory 3\n-----\nPopular (with Playboi Carti & Madonna) - Music from the HBO Original Series\nColumbia\nCreepin' (with The Weeknd & 21 Savage)\nFast Car\nUntil I Found You (with Em Beihold) - Em Beihold Version\ngolden hour\nSay Yes To Heaven\n\nCategory 6\n-----\nDance The Night (From Barbie The Album)\nFlowers\nCalm Down (with Selena Gomez)\nEyes Closed\nCUFF IT\nMona Lisa (Spider-Man: Across the Spider-Verse)\n\nCategory 2\n-----\nfukumean\nSeven (feat. Latto) (Explicit Ver.)\nCupid - Twin Ver.\nPeople\nBaby Don't Hurt Me\nBoy's a Liar Pt. 2\nDaylight\nMOJABI GHOST\nRush\nI'm Good (Blue)\nHere With Me\n(It Goes Like) Nanana - Edit\nUnholy (feat. Kim Petras)\n\nCategory 1\n-----\nDie For You - Remix\n\nCategory 7\n-----\nLast Night\n\n\n\n\n\nK Means Clustering\nUsing K Means clustering, I will be choosing to break my playlist into 3 smaller playlists.\n\nfrom sklearn.cluster import KMeans\nimport seaborn as sns\n%matplotlib inline\nplaylist_tracks = df[['artist','name','acousticness','danceability','energy',\n                      'liveness', 'instrumentalness','speechiness','valence']]\n\nkmeans = KMeans(n_clusters = 3)\nkmeans.fit(playlist_tracks.drop(['artist', 'name'], axis = 1))\n\nKMeans(n_clusters=3)\n\n\n\nsns.countplot(x=[str(group) for group in kmeans.labels_], color = 'lightblue')\n\n&lt;AxesSubplot:ylabel='count'&gt;\n\n\n\n\n\n\n\nVisualizing the Clusters\nMoving forward, let’s look at differences in the audio features of each group.\n\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(playlist_tracks.drop(['artist', 'name'], axis = 1))\nscaled_data = scaler.transform(playlist_tracks.drop(['artist', 'name'], axis = 1))\n\n\nfrom sklearn.decomposition import PCA\npca = PCA(n_components =2)\npca.fit(scaled_data)\ndata_pca = pca.transform(scaled_data)\n\nplt.scatter(data_pca[:,0], data_pca[:,1], c = list(kmeans.labels_), cmap = 'Paired')\nplt.xlabel('PC1: {:.3f}'.format(pca.explained_variance_ratio_[0]), size = 15)\nplt.ylabel('PC2: {:.3f}'.format(pca.explained_variance_ratio_[1]), size = 15)\n\nText(0, 0.5, 'PC2: 0.206')\n\n\n\n\n\n\nplot = sns.scatterplot(x=data_pca[:,0], y=data_pca[:,1], hue = list(kmeans.labels_),\n                       alpha = 0.66, \n                       #size = data_pca[:,1], sizes = (50,200),\n                       palette = 'viridis', edgecolor = 'black', cmap='Paired')\nplot.set_title('PCA ANALYSIS', size = 16, weight='bold')\n\nplt.xlabel('PC1: {:.3f}'.format(pca.explained_variance_ratio_[0]), size = 15)\nplt.ylabel('PC2: {:.3f}'.format(pca.explained_variance_ratio_[1]), size = 15)\n\nText(0, 0.5, 'PC2: 0.206')\n\n\n\n\n\n\nplaylist_tracks['group'] = list(kmeans.labels_)\nplaylist_tracks = playlist_tracks.astype({'group': str})\n\nmeans = pd.DataFrame(index = range(0,3), \n                    columns = list(playlist_tracks[playlist_tracks['group'] == '0'].describe().loc['mean'].index))\nmeans.iloc[0] = playlist_tracks[playlist_tracks['group'] == '0'].describe().loc['mean']\nmeans.iloc[1] = playlist_tracks[playlist_tracks['group'] == '1'].describe().loc['mean']\nmeans.iloc[2] = playlist_tracks[playlist_tracks['group'] == '2'].describe().loc['mean']\nmeans\n\nc:\\Users\\Hannah Luebbering\\.conda\\envs\\cse160\\lib\\site-packages\\ipykernel_launcher.py:1: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\n\n\n\n\n\nacousticness\ndanceability\nenergy\nliveness\ninstrumentalness\nspeechiness\nvalence\n\n\n\n\n0\n0.211471\n0.738905\n0.710381\n0.182595\n0.009162\n0.089543\n0.760476\n\n\n1\n0.121411\n0.654211\n0.700368\n0.194463\n0.044511\n0.079705\n0.346205\n\n\n2\n0.6363\n0.5515\n0.47261\n0.13302\n0.024815\n0.04123\n0.3029"
  }
]