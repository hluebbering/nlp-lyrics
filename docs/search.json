[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "https://www.tensorflow.org/install https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment?text=I+like+you.+I+love+you https://aeturrell.github.io/coding-for-economists/vis-common-plots.html"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NLP Song Lyrics",
    "section": "",
    "text": "Spotify API\nGoal. Using machine learning to predict the mood of music from song lyrics and audio features.\nThe following project uses Python implementation that extracts and analyzes information about songs in a Spotify playlist using the Spotify Web API. We then use the lyricsgenius package to search for and save the lyrics of specific songs from the Genius lyrics website. We then implement a Python script that contains several functions for cleaning song lyrics and determining the sentiment of the lyrics.\nIn summary, the code retrieves and cleans song lyrics, removes stopwords and performs lemmatization, and finally determines the sentiment of the lyrics using pre-trained models for sentiment analysis.\nTo access data from Spotify, we need to import the spotipy library and the SpotifyClientCredentials module. Additionally, we will be utilizing the pandas and IPython packages for data manipulation and display. In order to authenticate our access to the Spotify API, we must provide our client ID and client secret. Once authenticated, we can use the spotipy module to interact with the Spotify API and retrieve data.\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nimport pandas as pd\nfrom IPython.core.display import HTML\n\nclient_id = \"xxx\"\nclient_secret = \"xxx\"\nsp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(client_id, client_secret))\nThe following Python script contains various functions optimized for efficiently cleaning song lyrics and determining their sentiment. To get started, the script below imports two fundamental libraries, lyricsgenius and BeautifulSoup. Next, through the initialization of the genius variable, one can access the Genius API and retrieve the lyrics of any given song, such as “Too Many Nights” by Metro Boomin.\nimport lyricsgenius\nfrom bs4 import BeautifulSoup\n\ngenius = lyricsgenius.Genius(\"epFCxujgBe-Y6WrkZedI8kerKxiCpR6Rh0DAHYNlKDf9B4H1nXTdZIkj7krNUHVV\")\nsong = genius.search_song(\"Too Many Nights\", \"Metro Boomin\")\n# song.save_lyrics()\n\nSearching for \"Too Many Nights\" by Metro Boomin...\nDone.\nTo summarize, the code efficiently collects data and performs text analysis on every song in a playlist. Specifically, it systematically processes a list of tracks and corresponding artists while simultaneously conducting a thorough cleaning procedure on the lyrics. The cleaning process involves removing all nonessential characters, resulting in a more precise depiction of the song’s content. The outcome is a comprehensive frequency analysis of each word in a song’s lyrics, providing deeper insights into the overall conveyed message.\nAdditionally, the program computes a sentiment score for each song based on the lyrics, indicating whether the lyrics are positive, negative, or neutral. It also collects information about the song and artist, such as the release date, length, popularity, and genre. Finally, the program compiles all this information into a dataframe for further analysis.\nlyrics_dict = {}\ndict_ls = []\n\nfor i in range(len(df)):\n    song_name = df['name'][i].partition(' (')[0]\n    artist_name = df['artist'][i]\n    track_lyrics = clean_song_lyrics(song_name, artist_name)\n    track_lyrics = remove_stopwords_lyrics(track_lyrics)\n    \n    for k in (track_lyrics):\n        if k in lyrics_dict:\n            lyrics_dict[k] += 1\n        else:\n            lyrics_dict[k] = 1\n            \n    sent_score = get_lyric_sentiment(track_lyrics)\n    sent_score['track_name'] = song_name\n    sent_score['artist_name'] = artist_name\n    sent_score['release_date'] = df['release_date'][i]\n    sent_score['length'] = df['length'][i]\n    sent_score['popularity'] = df['popularity'][i]\n    sent_score['artist_pop'] = df['artist_pop'][i]\n    sent_score['artist_genres'] = df['artist_genres'][i]\n    sent_score['acousticness'] = df['acousticness'][i]\n    sent_score['danceability'] = df['danceability'][i]\n    sent_score['energy'] = df['energy'][i]\n    sent_score['instrumentalness'] = df['instrumentalness'][i]\n    sent_score['liveness'] = df['liveness'][i]\n    sent_score['loudness'] = df['loudness'][i]\n    sent_score['speechiness'] = df['speechiness'][i]\n    sent_score['tempo'] = df['tempo'][i]\n    sent_score['valence'] = df['valence'][i]\n    \n    dict_ls.append(sent_score)\n\nSearching for \"MELTDOWN\" by Travis Scott...\nDone.\nSearching for \"Barbie World\" by Nicki Minaj...\nDone.\nSearching for \"Cruel Summer\" by Taylor Swift...\nDone.\nSearching for \"vampire\" by Olivia Rodrigo...\nDone.\nSearching for \"Dance The Night\" by Dua Lipa...\nDone.\nSearching for \"Enough Is Enough\" by Post Malone...\nDone.\nSearching for \"What Was I Made For? [From The Motion Picture \"Barbie\"]\" by Billie Eilish...\nDone.\nSearching for \"Popular\" by The Weeknd...\nDone.\nSearching for \"Super Shy\" by NewJeans...\nDone.\nSearching for \"Paint The Town Red\" by Doja Cat...\nDone.\nSearching for \"K-POP\" by Travis Scott...\nDone.\nSearching for \"Seven\" by Jung Kook...\nDone.\nSearching for \"(It Goes Like) Nanana - Edit\" by Peggy Gou...\nDone.\nSearching for \"Calm Down\" by Rema...\nDone.\nSearching for \"LALA\" by Myke Towers...\nDone.\nSearching for \"Flowers\" by Miley Cyrus...\nDone.\nSearching for \"Chemical\" by Post Malone...\nDone.\nSearching for \"fukumean\" by Gunna...\nDone.\nSearching for \"Columbia\" by Quevedo...\nDone.\nSearching for \"As It Was\" by Harry Styles...\nDone.\nSearching for \"Kill Bill\" by SZA...\nDone.\nSearching for \"Creepin'\" by Metro Boomin...\nDone.\nSearching for \"Boy's a Liar Pt. 2\" by PinkPantheress...\nDone.\nSearching for \"Daylight\" by David Kushner...\nDone.\nSearching for \"WHERE SHE GOES\" by Bad Bunny...\nDone.\nSearching for \"All My Life\" by Lil Durk...\nDone.\nSearching for \"Baby Don't Hurt Me\" by David Guetta...\nDone.\nSearching for \"Cupid - Twin Ver.\" by FIFTY FIFTY...\nDone.\nSearching for \"People\" by Libianca...\nDone.\nSearching for \"Fast Car\" by Luke Combs...\nDone.\nSearching for \"Moonlight\" by Kali Uchis...\nDone.\nSearching for \"What It Is\" by Doechii...\nDone.\nSearching for \"Die For You - Remix\" by The Weeknd...\nDone.\nSearching for \"I Ain't Worried\" by OneRepublic...\nDone.\nSearching for \"Calling\" by Metro Boomin...\nDone.\nSearching for \"From The Start\" by Laufey...\nDone.\nSearching for \"Snooze\" by SZA...\nDone.\nSearching for \"Karma\" by Taylor Swift...\nDone.\nSearching for \"I'm Good\" by David Guetta...\nDone.\nSearching for \"Rush\" by Troye Sivan...\nDone.\nSearching for \"Until I Found You\" by Stephen Sanchez...\nDone.\nSearching for \"Sprinter\" by Dave...\nDone.\nSearching for \"CUFF IT\" by Beyoncé...\nDone.\nSearching for \"Miracle\" by Calvin Harris...\nDone.\nSearching for \"Nonsense\" by Sabrina Carpenter...\nDone.\nSearching for \"Here With Me\" by d4vd...\nDone.\nSearching for \"Dial Drunk\" by Noah Kahan...\nDone.\nSearching for \"Say Yes To Heaven\" by Lana Del Rey...\nDone.\nSearching for \"Last Night\" by Morgan Wallen...\nDone.\nSearching for \"Unholy\" by Sam Smith...\nDone.\ndf_final = pd.DataFrame(dict_ls)\ndf_final = df_final[['track_name', 'artist_name', 'release_date', 'length', 'popularity', \n         'artist_pop', 'artist_genres', 'acousticness', 'danceability', 'energy',\n         'instrumentalness', 'liveness', 'loudness', 'speechiness', 'tempo', 'valence',\n         'sadness', 'joy', 'love', 'anger', 'fear', 'surprise', 'LABEL_0',\n         'LABEL_1', 'LABEL_2', 'NEGATIVE', 'POSITIVE']]\n\n# df_final.to_csv('top_songs_us.csv', index=False)\ntrack_name\nartist_name\nrelease_date\nlength\npopularity\nartist_pop\nartist_genres\nacousticness\ndanceability\nenergy\n...\njoy\nlove\nanger\nfear\nsurprise\nLABEL_0\nLABEL_1\nLABEL_2\nNEGATIVE\nPOSITIVE\n\n\n\n\n0\nMELTDOWN\nTravis Scott\n2023-07-28\n246133\n92\n93\n[hip hop, rap, slap house]\n0.012\n0.557\n0.774\n...\n0.099706\n0.003778\n0.318775\n0.510471\n0.005726\n0.304234\n0.609486\n0.086280\n0.988320\n0.011679\n\n\n1\nBarbie World\nNicki Minaj\n2023-06-23\n109750\n94\n86\n[hip pop, pop, queens hip hop, rap]\n0.519\n0.770\n0.580\n...\n0.643529\n0.011229\n0.216599\n0.051564\n0.006760\n0.304938\n0.641082\n0.053980\n0.996903\n0.003097\n\n\n2\nCruel Summer\nTaylor Swift\n2019-08-23\n178426\n99\n100\n[pop]\n0.117\n0.552\n0.702\n...\n0.237114\n0.017189\n0.406948\n0.024178\n0.003635\n0.285380\n0.609290\n0.105329\n0.994155\n0.005845\n\n\n\n\n3 rows × 27 columns\nIn summary, the above code aims to collect and refine song lyrics by eliminating stopwords and conducting lemmatization. Subsequently, it employs pre-trained models for sentiment analysis to determine the prevailing emotion conveyed in the lyrics, providing valuable insights into the overall tone and message of the song."
  },
  {
    "objectID": "index.html#display-spotify-playlists",
    "href": "index.html#display-spotify-playlists",
    "title": "NLP Song Lyrics",
    "section": "Display Spotify Playlists",
    "text": "Display Spotify Playlists\nLet’s take a look at the popular Spotify playlists. Below, the code retrieves a range of Spotify playlists and generates a dataframe that contains various details about each playlist, such as its name, ID, description, thumbnail image, and total number of tracks. The resulting dataframe is displayed as an HTML table, which features thumbnail images for every playlist.\n\nusername = \"spotify\"\nmy_playlists = sp.user_playlists(username)\n\n\n\n\n\n\n\nthumbnail\nplaylist_name\nplaylist_id\ndescription\ntotal\n\n\n\n\n0\n\nToday's Top Hits\n37i9dQZF1DXcBWIGoYBM5M\nTravis Scott is on top of the Hottest 50!\n50\n\n\n1\n\nRapCaviar\n37i9dQZF1DX0XUsuxWHRQd\nMusic from Travis Scott, Drake and Latto.\n50\n\n\n2\n\nHot Country\n37i9dQZF1DX1lVhptIYRda\nToday's top country hits. Cover: Brett Young\n50\n\n\n3\n\nViva Latino\n37i9dQZF1DX10zKzsJ2jva\nToday's top Latin hits, elevando nuestra música. Cover: Grupo Frontera & Grupo Firme\n50\n\n\n4\n\nNew Music Friday\n37i9dQZF1DX4JAvHpjipBk\nNew music from Doja Cat, Lil Yachty, Bebe Rexha & David Guetta, Feid, Halle, Cordae and more!\n100"
  },
  {
    "objectID": "index.html#get-tracks-from-playlist",
    "href": "index.html#get-tracks-from-playlist",
    "title": "NLP Song Lyrics",
    "section": "Get Tracks from Playlist",
    "text": "Get Tracks from Playlist\nThis code uses Spotify’s API to extract various details about songs from a given playlist. It obtains metadata such as track name, album name, and release date, as well as track features like danceability and tempo. Additionally, it collects data on the artist’s genre and popularity. Once the data has been extracted, it is organized and presented in a Pandas DataFrame for easy viewing.\n\n# Get playlist song features and artist info\ndef playlist_features(id, artist_id, playlist_id):\n    \n    # Create Spotify API client variables\n    meta = sp.track(id)\n    audio_features = sp.audio_features(id)\n    artist_info = sp.artist(artist_id)\n    playlist_info = sp.playlist(playlist_id)\n\n    # Metadata\n    name = meta['name']\n    track_id = meta['id']\n    album = meta['album']['name']\n    artist = meta['album']['artists'][0]['name']\n    artist_id = meta['album']['artists'][0]['id']\n    release_date = meta['album']['release_date']\n    length = meta['duration_ms']\n    popularity = meta['popularity']\n\n    # Main artist name, popularity, genre\n    artist_pop = artist_info[\"popularity\"]\n    artist_genres = artist_info[\"genres\"]\n\n    # Track features\n    acousticness = audio_features[0]['acousticness']\n    danceability = audio_features[0]['danceability']\n    energy = audio_features[0]['energy']\n    instrumentalness = audio_features[0]['instrumentalness']\n    liveness = audio_features[0]['liveness']\n    loudness = audio_features[0]['loudness']\n    speechiness = audio_features[0]['speechiness']\n    tempo = audio_features[0]['tempo']\n    valence = audio_features[0]['valence']\n    key = audio_features[0]['key']\n    mode = audio_features[0]['mode']\n    time_signature = audio_features[0]['time_signature']\n    \n    # Basic playlist info\n    playlist_name = playlist_info['name']\n\n    return [name, track_id, album, artist, artist_id, release_date, length, popularity, \n            artist_pop, artist_genres, acousticness, danceability, \n            energy, instrumentalness, liveness, loudness, speechiness, \n            tempo, valence, key, mode, time_signature, playlist_name]\n\n\ndef get_playlist_tracks(playlist_URI):\n    tracks = []\n    results = sp.playlist_tracks(playlist_URI)\n    tracks = results[\"items\"]\n    while results[\"next\"]:\n        results = sp.next(results)\n        tracks.extend(results[\"items\"])\n    return tracks\n\nTo analyze a particular playlist, simply copy the URL from the Spotify Player interface and input it into the following code. The get_playlist_tracks method retrieves a comprehensive list of track IDs and their corresponding artists from the selected playlist.\n\n# Spotify playlist url\nplaylist_ids = []\ntrack_ids = []\nartist_uris = []\n\n# Extract song ids and artists from playlist\nplaylist_URI = \"37i9dQZF1DXcBWIGoYBM5M\"\nfor i in get_playlist_tracks(playlist_URI):\n    track_ids.append(i[\"track\"][\"id\"])\n    artist_uris.append(i[\"track\"][\"artists\"][0][\"uri\"])\n    playlist_ids.append(playlist_URI)\n\nWith the above code, it is possible to seamlessly gather essential information regarding songs and artists from any Spotify playlist identified by its URI. This process enables the extraction of data such as track IDs, artist URIs, and playlist IDs.\nTo extract further information about the songs, the code below iterates through each track ID in the playlist and utilizes the function we previously created. From there, we create a Pandas dataframe by passing in the extracted information and providing the desired column header names.\n\n# Loop over track ids\nall_tracks = [\n    playlist_features(track_ids[i], artist_uris[i], playlist_ids[i])\n    for i in range(len(track_ids))\n]\n\n\n\n\n\n\n\n\n\n\nname\nartist\nrelease_date\npopularity\nartist_pop\nartist_genres\nacousticness\ndanceability\nenergy\ninstrumentalness\nliveness\nloudness\nspeechiness\ntempo\nvalence\nplaylist\n\n\n\n\n0\nMELTDOWN (feat. Drake)\nTravis Scott\n2023-07-28\n92\n93\n[hip hop, rap, slap house]\n0.0120\n0.557\n0.774\n0.000000\n0.396\n-5.275\n0.3510\n111.975\n0.397\nToday's Top Hits\n\n\n1\nBarbie World (with Aqua) [From Barbie The Album]\nNicki Minaj\n2023-06-23\n94\n86\n[hip pop, pop, queens hip hop, rap]\n0.5190\n0.770\n0.580\n0.000127\n0.233\n-8.393\n0.2470\n144.072\n0.753\nToday's Top Hits\n\n\n2\nCruel Summer\nTaylor Swift\n2019-08-23\n99\n100\n[pop]\n0.1170\n0.552\n0.702\n0.000021\n0.105\n-5.707\n0.1570\n169.994\n0.564\nToday's Top Hits\n\n\n3\nvampire\nOlivia Rodrigo\n2023-06-30\n98\n84\n[pop]\n0.1690\n0.511\n0.532\n0.000000\n0.311\n-5.745\n0.0560\n137.827\n0.322\nToday's Top Hits\n\n\n4\nDance The Night (From Barbie The Album)\nDua Lipa\n2023-05-25\n96\n86\n[dance pop, pop, uk pop]\n0.0207\n0.671\n0.845\n0.000000\n0.329\n-4.930\n0.0480\n110.056\n0.775\nToday's Top Hits\n\n\n5\nEnough Is Enough\nPost Malone\n2023-07-28\n83\n89\n[dfw rap, melodic rap, pop, rap]\n0.0140\n0.483\n0.768\n0.000000\n0.109\n-4.911\n0.0344\n166.061\n0.332\nToday's Top Hits\n\n\n\n\n\n\n\n\nTop Artist Genres\nThe following code segment generates a dictionary that contains the frequency of artist genres, which is then converted into a dataframe sorted by frequency. The code accomplishes this by tallying the number of occurrences of each genre in a list called artist_genres. The count is performed using a dictionary named genres_dict, and the resulting tallies are stored in a dataframe named df_genres, which exhibits the genres and the number of times they occur.\n\ngenres_dict = {}\nfor x in df.artist_genres:\n    for ii in x:\n        if ii in genres_dict:\n            genres_dict[ii] += 1\n        else:\n            genres_dict[ii] = 1\nprint(genres_dict)\n\n# Convert Dictionary to Dataframe\ndf_genres = pd.DataFrame(genres_dict.items(), columns=['Genre', 'Freq']).sort_values('Freq', ascending=False)\ndf_genres = df_genres.reset_index(drop = True)\n\n{'hip hop': 5, 'rap': 11, 'slap house': 2, 'hip pop': 1, 'pop': 24, 'queens hip hop': 1, 'dance pop': 5, 'uk pop': 2, 'dfw rap': 2, 'melodic rap': 3, 'art pop': 2, 'electropop': 1, 'canadian contemporary r&b': 2, 'canadian pop': 2, 'k-pop': 2, 'k-pop girl group': 2, 'electra': 1, 'float house': 1, 'afrobeats': 2, 'nigerian pop': 1, 'reggaeton': 2, 'trap latino': 3, 'urbano latino': 3, 'atl hip hop': 1, 'trap': 2, 'rap canario': 1, 'r&b': 3, 'bedroom pop': 2, 'gen z singer-songwriter': 3, 'singer-songwriter pop': 2, 'chicago drill': 1, 'chicago rap': 1, 'drill': 1, 'pop rap': 1, 'big room': 2, 'edm': 3, 'pop dance': 2, 'contemporary country': 2, 'country': 1, 'colombian pop': 1, 'alternative r&b': 1, 'piano rock': 1, 'australian pop': 1, 'viral pop': 1, 'uk hip hop': 1, 'electro house': 1, 'house': 1, 'progressive house': 1, 'uk dance': 1, 'bedroom r&b': 1, 'pov: indie': 1}"
  },
  {
    "objectID": "index.html#nlp",
    "href": "index.html#nlp",
    "title": "NLP Song Lyrics",
    "section": "NLP",
    "text": "NLP\nSubsequently, the process involves the implementation of pipeline classes to carry out predictions using models accessible in the Hub. The code imports and employs multiple transformer models specifically designed for text classification and sentiment analysis. Specifically, the following procedure creates three distinct pipelines, each equipped with different models that facilitate the assessment of emotions and sentiment in textual content.\n\nimport transformers\nfrom transformers import pipeline\n#import tensorflow as tf\n## python -m pip install \"tensorflow&lt;2.11\"\n# python -m pip install \"protobuf&lt;3.2\"\n\nclassifier = pipeline(\"text-classification\",model='bhadresh-savani/distilbert-base-uncased-emotion', return_all_scores=True)\nclassifier2 = pipeline(\"text-classification\",model='cardiffnlp/twitter-roberta-base-sentiment', return_all_scores=True)\nclassifier3 = pipeline(\"sentiment-analysis\", return_all_scores=True)\n\nThe get_lyric_sentiment function takes in pre-processed lyrics as input and produces a dictionary of sentiment scores. It leverages three distinct classifiers to calculate the scores and aggregates them into a final result. For instance, one of these classifiers is the distilbert-base-uncased-emotion model, specifically trained to detect “emotions in texts such as sadness, joy, love, anger, fear, and surprise”.\n\ndef get_lyric_sentiment(cleaned_lyrics):\n    \n    x = ' '.join(cleaned_lyrics)\n    prediction = classifier(x, truncation = True)\n\n    song_score = {j['label']: j['score'] for j in prediction[0]}\n    prediction2 = classifier2(x, truncation=True, max_length=512)\n    for k in prediction2[0]:\n        song_score[k['label']] = k['score']\n\n    prediction3 = classifier3(x, truncation=True)\n    for k3 in prediction3[0]:\n        song_score[k3['label']] = k3['score']\n\n    return song_score\n\nIf the lyric sequence contains more than 512 tokens, it will trigger an error message indicating an exception encountered in the ‘embeddings’ layer. However, we have implemented measures to properly manage lyric sequences that exceed 512 words in the function mentioned above."
  },
  {
    "objectID": "index.html#spotify-songs---similarity-search",
    "href": "index.html#spotify-songs---similarity-search",
    "title": "NLP Song Lyrics",
    "section": "Spotify Songs - Similarity Search",
    "text": "Spotify Songs - Similarity Search\nBelow, we create a query to retrieve similar elements based on Euclidean distance. In mathematics, the Euclidean distance between two points is the length of the line segment between the two points. In this sense, the closer the distance is to 0, the more similar the songs are.\n\nKNN Algorithm\nThe k-Nearest Neighbors (KNN) algorithm searches for k similar elements based on a query point at the center within a predefined radius.\n\n# Get a song string search\ndef getMusicName(elem):\n    return f\"{elem['artist']} - {elem['name']}\"\n\ndef knnQuery(queryPoint, arrCharactPoints, k):\n    queryVals = queryPoint.tolist()\n    distVals = []\n    \n    # Copy of dataframe indices and data\n    tmp = arrCharactPoints.copy(deep = True)  \n    for index, row in tmp.iterrows():\n        feat = row.values.tolist()\n        \n        # Calculate sum of squared differences\n        ssd = sum(abs(feat[i] - queryVals[i]) ** 2 for i in range(len(queryVals)))\n        \n        # Get euclidean distance\n        distVals.append(ssd ** 0.5)\n        \n    tmp['distance'] = distVals\n    tmp = tmp.sort_values('distance')\n    \n    # K closest and furthest points\n    return tmp.head(k).index, tmp.tail(k).index\n\n\n# Execute KNN removing the query point\ndef querySimilars(df, columns, idx, func, param):\n    arr = df[columns].copy(deep = True)\n    queryPoint = arr.loc[idx]\n    arr = arr.drop([idx])\n    return func(queryPoint, arr, param)\n\nKNN Query Example.\nOur function allows us to create personalized query points and modify the columns to explore other options. For example, the following code selects a specific set of song attributes and then searches for the \\(k\\) highest values of these attributes set equal to one.\nLet’s search for \\(k=3\\) similar songs to a query point \\(\\textrm{songIndex} = 6\\).\n\nfrom sklearn import preprocessing \n\nscaler=preprocessing.MinMaxScaler() #instantiate a scaler\n# all the feature values are in the range [0,1] ,except of loudnes\n# so let's scale it to fit the exact same range\nloudness2 = df[\"loudness\"].values\nloudness_scaled=scaler.fit_transform(loudness2.reshape(-1, 1))\ndf['loudness_scaled'] = loudness_scaled\n\n\n# Select song and column attributes\nsongIndex = 4 # query point\ncolumns = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness', \n           'loudness_scaled', 'tempo', \n           'speechiness', 'valence']\n\n# Set query parameters\nfunc, param = knnQuery,3\n\n# Implement query\nresponse = querySimilars(df, columns, songIndex, func, param)\n\nprint(\"---- Query Point ----\")\nprint(getMusicName(df.loc[songIndex]))\nprint('---- k = 3 similar songs ----')\nfor track_id in response[0]:\n    track_name = getMusicName(df.loc[track_id])\n    print(track_name)\nprint('---- k = 3 nonsimilar songs ----')\nfor track_id in response[1]:\n    track_name = getMusicName(df.loc[track_id])\n    print(track_name)\n\n---- Query Point ----\nDua Lipa - Dance The Night (From Barbie The Album)\n---- k = 3 similar songs ----\nTravis Scott - MELTDOWN (feat. Drake)\nNoah Kahan - Dial Drunk (with Post Malone)\nRema - Calm Down (with Selena Gomez)\n---- k = 3 nonsimilar songs ----\nDoechii - What It Is (Solo Version)\nHarry Styles - As It Was\nMorgan Wallen - Last Night\n\n\nThe code below implements the same idea as above, but queries each track in a given playlist instead of a single defined query point.\n\nsimilar_count = {} # Similar songs count\nnonsimilar_count = {} # Non-similar songs count\n\nfor track_index in df.index:\n    # Implement query\n    response = querySimilars(df, columns, track_index, func, param)\n    \n    # Get similar songs\n    for similar_index in response[0]:\n        track = getMusicName(df.loc[similar_index])\n        if track in similar_count:\n            similar_count[track] += 1\n        else:\n            similar_count[track] = 1\n    \n    # Get non-similar songs\n    for nonsimilar_index in response[1]:\n        track = getMusicName(df.loc[nonsimilar_index])\n        if track in nonsimilar_count:\n            nonsimilar_count[track] += 1\n        else:\n            nonsimilar_count[track] = 1\n\n\nnonsimilar = dict(sorted(nonsimilar_count.items(), key=lambda item: item[1], reverse=True))\nprint('---- NON SIMILAR SONG COUNTS ----')\nfor track_name, track_count in nonsimilar.items():\n    if track_count &gt;= 8:\n        print(track_name, ':', track_count)\n\nsimilar = dict(sorted(similar_count.items(), key=lambda item: item[1], reverse=True))\nprint('\\n---- SIMILAR SONG COUNTS ----')\nfor track_name, track_count in similar.items():\n    if track_count &gt;= 5:\n        print(track_name, ':', track_count)\n\n---- NON SIMILAR SONG COUNTS ----\nMorgan Wallen - Last Night : 38\nThe Weeknd - Die For You - Remix : 31\nBillie Eilish - What Was I Made For? [From The Motion Picture \"Barbie\"] : 26\nHarry Styles - As It Was : 24\nDoechii - What It Is (Solo Version) : 19\nLaufey - From The Start : 12\n\n---- SIMILAR SONG COUNTS ----\nLil Durk - All My Life (feat. J. Cole) : 5\nDoechii - What It Is (Solo Version) : 5\nOneRepublic - I Ain't Worried : 5\nTaylor Swift - Cruel Summer : 5\nSZA - Kill Bill : 5\nDoja Cat - Paint The Town Red : 5\nQuevedo - Columbia : 5\nGunna - fukumean : 5\nSam Smith - Unholy (feat. Kim Petras) : 5"
  },
  {
    "objectID": "index.html#organized-songs-in-a-playlist",
    "href": "index.html#organized-songs-in-a-playlist",
    "title": "NLP Song Lyrics",
    "section": "Organized Songs in a Playlist",
    "text": "Organized Songs in a Playlist\n\nimport datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn import cluster, decomposition\n\n\nsongs = df[['name','acousticness', 'danceability', 'energy', 'instrumentalness', \n            'liveness', 'speechiness', 'tempo', 'valence',  'loudness_scaled']]\nsongs.describe()\n\n\n\n\n\n\n\n\n\nacousticness\ndanceability\nenergy\ninstrumentalness\nliveness\nspeechiness\ntempo\nvalence\nloudness_scaled\n\n\n\n\ncount\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n50.000000\n\n\nmean\n0.250266\n0.664640\n0.657402\n0.021944\n0.181618\n0.080130\n125.693800\n0.520218\n0.779203\n\n\nstd\n0.257309\n0.117373\n0.169266\n0.094434\n0.133191\n0.074653\n27.465254\n0.240977\n0.161298\n\n\nmin\n0.001260\n0.444000\n0.091100\n0.000000\n0.032200\n0.025400\n66.900000\n0.096900\n0.000000\n\n\n25%\n0.053300\n0.559500\n0.550250\n0.000000\n0.097025\n0.035325\n102.642250\n0.310000\n0.708313\n\n\n50%\n0.146500\n0.667500\n0.679500\n0.000004\n0.114500\n0.051600\n127.992000\n0.526500\n0.823084\n\n\n75%\n0.408250\n0.741500\n0.791250\n0.000128\n0.244250\n0.083150\n140.853000\n0.730500\n0.866962\n\n\nmax\n0.959000\n0.916000\n0.965000\n0.629000\n0.671000\n0.351000\n203.853000\n0.964000\n1.000000\n\n\n\n\n\n\n\n\nlabels = songs.values[:,0]\nX = songs.values[:,1:10]\nkmeans = cluster.AffinityPropagation(preference=-200)\nkmeans.fit(X)\n\nAffinityPropagation(preference=-200)\n\n\n\npredictions = {}\nfor p,n in zip(kmeans.predict(X),labels):\n    if not predictions.get(p):\n        predictions[p] = []\n        \n    predictions[p] += [n]\n\nfor p in predictions:\n    print(\"Category\",p)\n    print(\"-----\")\n    for n in predictions[p]:\n        print(n)\n    print(\"\")\n\nCategory 0\n-----\nWhat Was I Made For? [From The Motion Picture \"Barbie\"]\nKill Bill\nAttention\nLALA\nKarma\n\nCategory 4\n-----\nvampire\nWHERE SHE GOES\nBarbie World (with Aqua) [From Barbie The Album]\nSuper Shy\nCalling (Spider-Man: Across the Spider-Verse) (Metro Boomin & Swae Lee, NAV, feat. A Boogie Wit da Hoodie)\nAll My Life (feat. J. Cole)\nMoonlight\nSnooze\nI Ain't Worried\nElla Baila Sola\nNonsense\nMiracle (with Ellie Goulding)\nSprinter\n\nCategory 5\n-----\nCruel Summer\nAs It Was\nChemical\nWhat It Is (Solo Version)\n\nCategory 3\n-----\nPopular (with Playboi Carti & Madonna) - Music from the HBO Original Series\nColumbia\nCreepin' (with The Weeknd & 21 Savage)\nFast Car\nUntil I Found You (with Em Beihold) - Em Beihold Version\ngolden hour\nSay Yes To Heaven\n\nCategory 6\n-----\nDance The Night (From Barbie The Album)\nFlowers\nCalm Down (with Selena Gomez)\nEyes Closed\nCUFF IT\nMona Lisa (Spider-Man: Across the Spider-Verse)\n\nCategory 2\n-----\nfukumean\nSeven (feat. Latto) (Explicit Ver.)\nCupid - Twin Ver.\nPeople\nBaby Don't Hurt Me\nBoy's a Liar Pt. 2\nDaylight\nMOJABI GHOST\nRush\nI'm Good (Blue)\nHere With Me\n(It Goes Like) Nanana - Edit\nUnholy (feat. Kim Petras)\n\nCategory 1\n-----\nDie For You - Remix\n\nCategory 7\n-----\nLast Night\n\n\n\n\n\nK Means Clustering\nUsing K Means clustering, I will be choosing to break my playlist into 3 smaller playlists.\n\nfrom sklearn.cluster import KMeans\nimport seaborn as sns\n%matplotlib inline\nplaylist_tracks = df[['artist','name','acousticness','danceability','energy',\n                      'liveness', 'instrumentalness','speechiness','valence']]\n\nkmeans = KMeans(n_clusters = 3)\nkmeans.fit(playlist_tracks.drop(['artist', 'name'], axis = 1))\n\nKMeans(n_clusters=3)\n\n\n\nsns.countplot(x=[str(group) for group in kmeans.labels_], color = 'lightblue')\n\n&lt;AxesSubplot:ylabel='count'&gt;\n\n\n\n\n\n\n\nVisualizing the Clusters\nMoving forward, let’s look at differences in the audio features of each group.\n\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(playlist_tracks.drop(['artist', 'name'], axis = 1))\nscaled_data = scaler.transform(playlist_tracks.drop(['artist', 'name'], axis = 1))\n\n\nfrom sklearn.decomposition import PCA\npca = PCA(n_components =2)\npca.fit(scaled_data)\ndata_pca = pca.transform(scaled_data)\n\nplt.scatter(data_pca[:,0], data_pca[:,1], c = list(kmeans.labels_), cmap = 'Paired')\nplt.xlabel('PC1: {:.3f}'.format(pca.explained_variance_ratio_[0]), size = 15)\nplt.ylabel('PC2: {:.3f}'.format(pca.explained_variance_ratio_[1]), size = 15)\n\nText(0, 0.5, 'PC2: 0.206')\n\n\n\n\n\n\nplot = sns.scatterplot(x=data_pca[:,0], y=data_pca[:,1], hue = list(kmeans.labels_),\n                       alpha = 0.66, \n                       #size = data_pca[:,1], sizes = (50,200),\n                       palette = 'viridis', edgecolor = 'black', cmap='Paired')\nplot.set_title('PCA ANALYSIS', size = 16, weight='bold')\n\nplt.xlabel('PC1: {:.3f}'.format(pca.explained_variance_ratio_[0]), size = 15)\nplt.ylabel('PC2: {:.3f}'.format(pca.explained_variance_ratio_[1]), size = 15)\n\nText(0, 0.5, 'PC2: 0.206')\n\n\n\n\n\n\nplaylist_tracks['group'] = list(kmeans.labels_)\nplaylist_tracks = playlist_tracks.astype({'group': str})\n\nmeans = pd.DataFrame(index = range(0,3), \n                    columns = list(playlist_tracks[playlist_tracks['group'] == '0'].describe().loc['mean'].index))\nmeans.iloc[0] = playlist_tracks[playlist_tracks['group'] == '0'].describe().loc['mean']\nmeans.iloc[1] = playlist_tracks[playlist_tracks['group'] == '1'].describe().loc['mean']\nmeans.iloc[2] = playlist_tracks[playlist_tracks['group'] == '2'].describe().loc['mean']\nmeans\n\nc:\\Users\\Hannah Luebbering\\.conda\\envs\\cse160\\lib\\site-packages\\ipykernel_launcher.py:1: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\n\n\n\n\n\nacousticness\ndanceability\nenergy\nliveness\ninstrumentalness\nspeechiness\nvalence\n\n\n\n\n0\n0.211471\n0.738905\n0.710381\n0.182595\n0.009162\n0.089543\n0.760476\n\n\n1\n0.121411\n0.654211\n0.700368\n0.194463\n0.044511\n0.079705\n0.346205\n\n\n2\n0.6363\n0.5515\n0.47261\n0.13302\n0.024815\n0.04123\n0.3029"
  }
]